// Auto-generated Jounce Client Bundle
// DO NOT EDIT - Generated by Jounce compiler

import { h, RPCClient, mountComponent, navigate, getRouter, onMount, onUnmount, onUpdate, onError, ErrorBoundary, Suspense } from './client-runtime.js';
import { signal, persistentSignal, computed, effect, batch } from './reactivity.js';

// Node.js crypto module (for tests and server-side code)
let __nodeCrypto;
try {
  if (typeof require !== 'undefined') {
    __nodeCrypto = require('crypto');
  }
} catch (e) {
  // crypto module not available (browser environment)
}

// Crypto helpers - use Node.js crypto module when available
const __crypto_sha256 = function(data) {
  if (__nodeCrypto) return __nodeCrypto.createHash('sha256').update(data).digest('hex');
  return ''; // fallback
};
const __crypto_sha1 = function(data) {
  if (__nodeCrypto) return __nodeCrypto.createHash('sha1').update(data).digest('hex');
  return ''; // fallback
};
const __crypto_md5 = function(data) {
  if (__nodeCrypto) return __nodeCrypto.createHash('md5').update(data).digest('hex');
  return ''; // fallback
};
const __crypto_hmac = function(algo, key, data) {
  if (__nodeCrypto) return __nodeCrypto.createHmac(algo, key).update(data).digest('hex');
  return ''; // fallback
};
const __crypto_random_bytes = function(len) {
  if (__nodeCrypto) return Array.from(__nodeCrypto.randomBytes(len));
  return Array(len).fill(0); // fallback
};
const __crypto_pbkdf2 = function(password, salt, iterations, keylen, digest) {
  if (__nodeCrypto) return __nodeCrypto.pbkdf2Sync(password, salt, iterations, keylen, digest).toString('hex');
  return ''; // fallback
};

// Node.js fs module (for server-side file I/O)
let __nodeFs;
try {
  if (typeof require !== 'undefined') {
    __nodeFs = require('fs');
  }
} catch (e) {
  // fs module not available (browser environment)
}

// File system helpers - use Node.js fs module when available
const __fs_read_to_string = function(path) {
  if (__nodeFs) return __nodeFs.readFileSync(path, 'utf8');
  throw new Error('File I/O not available in browser');
};
const __fs_read_bytes = function(path) {
  if (__nodeFs) return Array.from(__nodeFs.readFileSync(path));
  throw new Error('File I/O not available in browser');
};
const __fs_write_string = function(path, data) {
  if (__nodeFs) { __nodeFs.writeFileSync(path, data, 'utf8'); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_write_bytes = function(path, data) {
  if (__nodeFs) { __nodeFs.writeFileSync(path, Buffer.from(data)); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_append_string = function(path, data) {
  if (__nodeFs) { __nodeFs.appendFileSync(path, data, 'utf8'); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_exists = function(path) {
  if (__nodeFs) return __nodeFs.existsSync(path);
  return false;
};
const __fs_metadata = function(path) {
  if (__nodeFs) {
    const stats = __nodeFs.statSync(path);
    const _size = stats.size;
    const _is_file = stats.isFile();
    const _is_directory = stats.isDirectory();
    const _created = stats.birthtimeMs;
    const _modified = stats.mtimeMs;
    const _accessed = stats.atimeMs;
    const _permissions = stats.mode & 0o777;
    return {
      size: _size,
      is_file: () => _is_file,
      is_directory: () => _is_directory,
      created: _created,
      modified: _modified,
      accessed: _accessed,
      permissions: _permissions,
      len: () => _size,
      is_readonly: () => (_permissions & 128) === 0
    };
  }
  throw new Error('File I/O not available in browser');
};
const __fs_read_dir = function(path) {
  if (__nodeFs) {
    const entries = __nodeFs.readdirSync(path, { withFileTypes: true });
    return entries.map(entry => {
      const fullPath = path + '/' + entry.name;
      const stats = __nodeFs.statSync(fullPath);
      const _size = stats.size;
      const _is_file = stats.isFile();
      const _is_directory = stats.isDirectory();
      const metadata = {
        size: _size,
        is_file: _is_file,
        is_directory: _is_directory,
        created: stats.birthtimeMs,
        modified: stats.mtimeMs,
        accessed: stats.atimeMs,
        permissions: stats.mode & 0o777
      };
      return {
        name: entry.name,
        path: fullPath,
        metadata: metadata,
        is_file: () => _is_file,
        is_directory: () => _is_directory
      };
    });
  }
  throw new Error('File I/O not available in browser');
};
const __fs_create_dir = function(path) {
  if (__nodeFs) { __nodeFs.mkdirSync(path); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_create_dir_all = function(path) {
  if (__nodeFs) { __nodeFs.mkdirSync(path, { recursive: true }); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_remove_file = function(path) {
  if (__nodeFs) { __nodeFs.unlinkSync(path); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_remove_dir = function(path) {
  if (__nodeFs) { __nodeFs.rmdirSync(path); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_remove_dir_all = function(path) {
  if (__nodeFs) { __nodeFs.rmSync(path, { recursive: true, force: true }); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_rename = function(from, to) {
  if (__nodeFs) { __nodeFs.renameSync(from, to); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_read_to_string_safe = function(path) {
  try { return Ok(__fs_read_to_string(path)); } catch (e) { return Err(e.message); }
};
const __fs_read_bytes_safe = function(path) {
  try { return Ok(__fs_read_bytes(path)); } catch (e) { return Err(e.message); }
};
const __fs_write_string_safe = function(path, data) {
  try { __fs_write_string(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_write_bytes_safe = function(path, data) {
  try { __fs_write_bytes(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_append_string_safe = function(path, data) {
  try { __fs_append_string(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_metadata_safe = function(path) {
  try { return Ok(__fs_metadata(path)); } catch (e) { return Err(e.message); }
};
const __fs_read_dir_safe = function(path) {
  try { return Ok(__fs_read_dir(path)); } catch (e) { return Err(e.message); }
};
const __fs_create_dir_safe = function(path) {
  try { __fs_create_dir(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_create_dir_all_safe = function(path) {
  try { __fs_create_dir_all(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_remove_file_safe = function(path) {
  try { __fs_remove_file(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_remove_dir_safe = function(path) {
  try { __fs_remove_dir(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_remove_dir_all_safe = function(path) {
  try { __fs_remove_dir_all(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_rename_safe = function(from, to) {
  try { __fs_rename(from, to); return Ok(undefined); } catch (e) { return Err(e.message); }
};

// Built-in type extensions
const Vec = Array; // Vec<T> is Array in JavaScript
Vec.new = function() { return []; }; // Vec::new() creates empty array
// String methods - ensure they work on both primitives and String objects
if (!String.prototype.len) {
  String.prototype.len = function() { return this.length; };
}
if (!String.prototype.is_empty) {
  String.prototype.is_empty = function() { return this.length === 0; };
}
if (!String.prototype.chars) {
  String.prototype.chars = function() { return this.split(''); };
}
if (!String.prototype.contains) {
  String.prototype.contains = function(substr) { return this.includes(substr); };
}
if (!String.prototype.starts_with) {
  String.prototype.starts_with = function(prefix) { return this.startsWith(prefix); };
}
if (!String.prototype.ends_with) {
  String.prototype.ends_with = function(suffix) { return this.endsWith(suffix); };
}
if (!String.prototype.to_lowercase) {
  String.prototype.to_lowercase = function() { return this.toLowerCase(); };
}
if (!String.prototype.char_code_at) {
  String.prototype.char_code_at = function(index) { return this.charCodeAt(index); };
}
if (!String.prototype.char_at) {
  String.prototype.char_at = function(index) { return this.charAt(index); };
}
if (!String.prototype.parse_int) {
  String.prototype.parse_int = function() { return parseInt(this, 10); };
}
if (!String.prototype.parse_float) {
  String.prototype.parse_float = function() { return parseFloat(this); };
}
if (!String.prototype.index_of) {
  String.prototype.index_of = function(substr) { return this.indexOf(substr); };
}
if (!String.prototype.clone) {
  String.prototype.clone = function() { return this.toString(); };
}
if (!String.prototype.push_str) {
  String.prototype.push_str = function(s) { return this + s; };
}
if (!String.prototype.to_string) {
  String.prototype.to_string = function() { return this.toString(); };
}
if (!Number.prototype.to_string) {
  Number.prototype.to_string = function() { return this.toString(); };
}
if (!Array.prototype.len) {
  Array.prototype.len = function() { return this.length; };
}
if (!Array.prototype.is_empty) {
  Array.prototype.is_empty = function() { return this.length === 0; };
}
if (!Array.prototype.clone) {
  Array.prototype.clone = function() { return this.slice(); };
}
if (!Object.prototype.keys) {
  Object.prototype.keys = function() { return Object.keys(this); };
}
if (!Object.prototype.clone) {
  Object.prototype.clone = function() { return JSON.parse(JSON.stringify(this)); };
}
if (!String.from_char_code) {
  String.from_char_code = function(code) { return String.fromCharCode(code); };
}
if (!String.new) {
  String.new = function() {
    const sb = { __value: "" };
    sb.push_str = function(s) { this.__value += s; };
    sb.toString = function() { return this.__value; };
    sb.valueOf = function() { return this.__value; };
    sb.clone = function() { return this.__value; };
    sb.len = function() { return this.__value.length; };
    sb.is_empty = function() { return this.__value.length === 0; };
    sb.contains = function(s) { return this.__value.includes(s); };
    sb.trim = function() { return this.__value.trim(); };
    sb.starts_with = function(s) { return this.__value.startsWith(s); };
    sb.ends_with = function(s) { return this.__value.endsWith(s); };
    sb.substring = function(start, end) { return this.__value.substring(start, end); };
    return sb;
  };
}
if (!String.from) {
  String.from = function(s) { return String(s); };
}

// Result<T, E> enum - represents success (Ok) or failure (Err)
const Result = { __proto__: null };
Result.prototype = {};
function Ok(data) { const v = { variant: "Ok", data: data }; v.__proto__ = Result.prototype; return v; }
function Err(data) { const v = { variant: "Err", data: data }; v.__proto__ = Result.prototype; return v; }
Result.prototype.is_ok = function() { return this.variant === "Ok"; };
Result.prototype.is_err = function() { return this.variant === "Err"; };
Result.prototype.unwrap = function() { if (this.variant === "Ok") return this.data; throw new Error("Called unwrap on Err"); };
Result.prototype.unwrap_err = function() { if (this.variant === "Err") return this.data; throw new Error("Called unwrap_err on Ok"); };
Result.prototype.unwrap_or = function(default_val) { return this.variant === "Ok" ? this.data : default_val; };
Result.Ok = Ok;
Result.Err = Err;

// Option<T> enum - represents Some value or None
const Option = { __proto__: null };
Option.prototype = {};
function Some(data) { const v = { variant: "Some", data: data }; v.__proto__ = Option.prototype; return v; }
const None = (() => { const v = { variant: "None" }; v.__proto__ = Option.prototype; return v; })();
Option.Some = Some;
Option.None = None;
Option.prototype.is_some = function() { return this.variant === "Some"; };
Option.prototype.is_none = function() { return this.variant === "None"; };
Option.prototype.unwrap = function() { if (this.variant === "Some") return this.data; throw new Error("Called unwrap on None"); };
Option.prototype.unwrap_or = function(default_val) { return this.variant === "Some" ? this.data : default_val; };

// HashMap<K, V> is a JavaScript Map
const HashMap = Map;
HashMap.new = function() { return new Map(); };
if (!Map.prototype.insert) {
  Map.prototype.insert = function(k, v) { this.set(k, v); };
}
if (!Map.prototype.contains_key) {
  Map.prototype.contains_key = function(k) { return this.has(k); };
}
if (!Map.prototype.get_or_default) {
  Map.prototype.get_or_default = function(k, def) { return this.has(k) ? this.get(k) : def; };
}
if (!Map.prototype.len) {
  Map.prototype.len = function() { return this.size; };
}
if (!Map.prototype.is_empty) {
  Map.prototype.is_empty = function() { return this.size === 0; };
}

// RPC Client Setup
// Auto-generated RPC client stubs
const client = new RPCClient(window.location.origin);


// Struct definitions
// Enum definitions
// Implementations
// Client function implementations
// Shared utility functions
// Stdlib module namespaces
const json = {
  parse: typeof parse !== 'undefined' ? parse : undefined,
  stringify: typeof stringify !== 'undefined' ? stringify : undefined,
  stringify_pretty: typeof stringify_pretty !== 'undefined' ? stringify_pretty : undefined,
  // Helper functions for creating JSON values
  null_: () => ({ variant: 'Null' }),
  bool: (b) => ({ variant: 'Bool', data: b }),
  number: (n) => ({ variant: 'Number', data: n }),
  string: (s) => ({ variant: 'String', data: s }),
  array: (arr) => ({ variant: 'Array', data: arr || [] }),
  object: (obj) => ({ variant: 'Object', data: obj || {} }),
};

const crypto = {
  sha256: typeof sha256 !== 'undefined' ? sha256 : undefined,
  sha1: typeof sha1 !== 'undefined' ? sha1 : undefined,
  md5: typeof md5 !== 'undefined' ? md5 : undefined,
  hmac_sha256: typeof hmac_sha256 !== 'undefined' ? hmac_sha256 : undefined,
  random_bytes: typeof random_bytes !== 'undefined' ? random_bytes : undefined,
  random_int: typeof random_int !== 'undefined' ? random_int : undefined,
  random_float: typeof random_float !== 'undefined' ? random_float : undefined,
  random_string: typeof random_string !== 'undefined' ? random_string : undefined,
  random_alphanumeric: typeof random_alphanumeric !== 'undefined' ? random_alphanumeric : undefined,
  random_hex: typeof random_hex !== 'undefined' ? random_hex : undefined,
  uuid_v4: typeof uuid_v4 !== 'undefined' ? uuid_v4 : undefined,
  base64_encode: typeof base64_encode !== 'undefined' ? base64_encode : undefined,
  base64_decode: typeof base64_decode !== 'undefined' ? base64_decode : undefined,
  hex_encode: typeof hex_encode !== 'undefined' ? hex_encode : undefined,
  hex_decode: typeof hex_decode !== 'undefined' ? hex_decode : undefined,
  hash_password_auto: typeof hash_password_auto !== 'undefined' ? hash_password_auto : undefined,
  generate_salt: typeof generate_salt !== 'undefined' ? generate_salt : undefined,
};

const fs = {
  read_to_string: typeof read_to_string !== 'undefined' ? read_to_string : undefined,
  read: typeof read !== 'undefined' ? read : undefined,
  write: typeof write !== 'undefined' ? write : undefined,
  write_bytes: typeof write_bytes !== 'undefined' ? write_bytes : undefined,
  append: typeof append !== 'undefined' ? append : undefined,
  exists: typeof exists !== 'undefined' ? exists : undefined,
  is_file: typeof is_file !== 'undefined' ? is_file : undefined,
  is_directory: typeof is_directory !== 'undefined' ? is_directory : undefined,
  metadata: typeof metadata !== 'undefined' ? metadata : undefined,
  create_dir: typeof create_dir !== 'undefined' ? create_dir : undefined,
  create_dir_all: typeof create_dir_all !== 'undefined' ? create_dir_all : undefined,
  remove_file: typeof remove_file !== 'undefined' ? remove_file : undefined,
  remove_dir: typeof remove_dir !== 'undefined' ? remove_dir : undefined,
  remove_dir_all: typeof remove_dir_all !== 'undefined' ? remove_dir_all : undefined,
  read_dir: typeof read_dir !== 'undefined' ? read_dir : undefined,
  copy: typeof copy !== 'undefined' ? copy : undefined,
  rename: typeof rename !== 'undefined' ? rename : undefined,
  current_dir: typeof current_dir !== 'undefined' ? current_dir : undefined,
  set_current_dir: typeof set_current_dir !== 'undefined' ? set_current_dir : undefined,
  canonicalize: typeof canonicalize !== 'undefined' ? canonicalize : undefined,
  symlink: typeof symlink !== 'undefined' ? symlink : undefined,
  read_link: typeof read_link !== 'undefined' ? read_link : undefined,
  set_permissions: typeof set_permissions !== 'undefined' ? set_permissions : undefined,
  walk_dir: typeof walk_dir !== 'undefined' ? walk_dir : undefined,
  glob: typeof glob !== 'undefined' ? glob : undefined,
};

const yaml = {
  parse: typeof yaml_parse !== 'undefined' ? yaml_parse : undefined,
  stringify: typeof yaml_stringify !== 'undefined' ? yaml_stringify : undefined,
  // Helper functions for creating YAML values
  yaml_null: typeof yaml_null !== 'undefined' ? yaml_null : undefined,
  yaml_bool: typeof yaml_bool !== 'undefined' ? yaml_bool : undefined,
  yaml_number: typeof yaml_number !== 'undefined' ? yaml_number : undefined,
  yaml_string: typeof yaml_string !== 'undefined' ? yaml_string : undefined,
  yaml_sequence: typeof yaml_sequence !== 'undefined' ? yaml_sequence : undefined,
  yaml_mapping: typeof yaml_mapping !== 'undefined' ? yaml_mapping : undefined,
};

// UI Components
export function App({} = {}) {
  let currentHole = signal(1);
  let p1h1 = signal(0);
  let p1h2 = signal(0);
  let p1h3 = signal(0);
  let p1h4 = signal(0);
  let p1h5 = signal(0);
  let p1h6 = signal(0);
  let p1h7 = signal(0);
  let p1h8 = signal(0);
  let p1h9 = signal(0);
  let p2h1 = signal(0);
  let p2h2 = signal(0);
  let p2h3 = signal(0);
  let p2h4 = signal(0);
  let p2h5 = signal(0);
  let p2h6 = signal(0);
  let p2h7 = signal(0);
  let p2h8 = signal(0);
  let p2h9 = signal(0);
  let p3h1 = signal(0);
  let p3h2 = signal(0);
  let p3h3 = signal(0);
  let p3h4 = signal(0);
  let p3h5 = signal(0);
  let p3h6 = signal(0);
  let p3h7 = signal(0);
  let p3h8 = signal(0);
  let p3h9 = signal(0);
  let p4h1 = signal(0);
  let p4h2 = signal(0);
  let p4h3 = signal(0);
  let p4h4 = signal(0);
  let p4h5 = signal(0);
  let p4h6 = signal(0);
  let p4h7 = signal(0);
  let p4h8 = signal(0);
  let p4h9 = signal(0);
  let p1CurrentScore = signal(0);
  let p2CurrentScore = signal(0);
  let p3CurrentScore = signal(0);
  let p4CurrentScore = signal(0);
  let p1Total = signal(0);
  let p2Total = signal(0);
  let p3Total = signal(0);
  let p4Total = signal(0);
  let updateCurrentScores = () => { if ((currentHole.value == 1)) {
  p1CurrentScore.value = p1h1.value;
  p2CurrentScore.value = p2h1.value;
  p3CurrentScore.value = p3h1.value;
  p4CurrentScore.value = p4h1.value;

  } else if ((currentHole.value == 2)) {
  p1CurrentScore.value = p1h2.value;
  p2CurrentScore.value = p2h2.value;
  p3CurrentScore.value = p3h2.value;
  p4CurrentScore.value = p4h2.value;

  } else if ((currentHole.value == 3)) {
  p1CurrentScore.value = p1h3.value;
  p2CurrentScore.value = p2h3.value;
  p3CurrentScore.value = p3h3.value;
  p4CurrentScore.value = p4h3.value;

  } else if ((currentHole.value == 4)) {
  p1CurrentScore.value = p1h4.value;
  p2CurrentScore.value = p2h4.value;
  p3CurrentScore.value = p3h4.value;
  p4CurrentScore.value = p4h4.value;

  } else if ((currentHole.value == 5)) {
  p1CurrentScore.value = p1h5.value;
  p2CurrentScore.value = p2h5.value;
  p3CurrentScore.value = p3h5.value;
  p4CurrentScore.value = p4h5.value;

  } else if ((currentHole.value == 6)) {
  p1CurrentScore.value = p1h6.value;
  p2CurrentScore.value = p2h6.value;
  p3CurrentScore.value = p3h6.value;
  p4CurrentScore.value = p4h6.value;

  } else if ((currentHole.value == 7)) {
  p1CurrentScore.value = p1h7.value;
  p2CurrentScore.value = p2h7.value;
  p3CurrentScore.value = p3h7.value;
  p4CurrentScore.value = p4h7.value;

  } else if ((currentHole.value == 8)) {
  p1CurrentScore.value = p1h8.value;
  p2CurrentScore.value = p2h8.value;
  p3CurrentScore.value = p3h8.value;
  p4CurrentScore.value = p4h8.value;

  } else if ((currentHole.value == 9)) {
  p1CurrentScore.value = p1h9.value;
  p2CurrentScore.value = p2h9.value;
  p3CurrentScore.value = p3h9.value;
  p4CurrentScore.value = p4h9.value;

  } };
  let recalculateTotals = () => { p1Total.value = ((((((((p1h1.value + p1h2.value) + p1h3.value) + p1h4.value) + p1h5.value) + p1h6.value) + p1h7.value) + p1h8.value) + p1h9.value);
p2Total.value = ((((((((p2h1.value + p2h2.value) + p2h3.value) + p2h4.value) + p2h5.value) + p2h6.value) + p2h7.value) + p2h8.value) + p2h9.value);
p3Total.value = ((((((((p3h1.value + p3h2.value) + p3h3.value) + p3h4.value) + p3h5.value) + p3h6.value) + p3h7.value) + p3h8.value) + p3h9.value);
p4Total.value = ((((((((p4h1.value + p4h2.value) + p4h3.value) + p4h4.value) + p4h5.value) + p4h6.value) + p4h7.value) + p4h8.value) + p4h9.value); };
  let updateP1 = (delta) => { if ((currentHole.value == 1)) {
  p1h1.value = (p1h1.value + delta);
  p1CurrentScore.value = p1h1.value;

  } else if ((currentHole.value == 2)) {
  p1h2.value = (p1h2.value + delta);
  p1CurrentScore.value = p1h2.value;

  } else if ((currentHole.value == 3)) {
  p1h3.value = (p1h3.value + delta);
  p1CurrentScore.value = p1h3.value;

  } else if ((currentHole.value == 4)) {
  p1h4.value = (p1h4.value + delta);
  p1CurrentScore.value = p1h4.value;

  } else if ((currentHole.value == 5)) {
  p1h5.value = (p1h5.value + delta);
  p1CurrentScore.value = p1h5.value;

  } else if ((currentHole.value == 6)) {
  p1h6.value = (p1h6.value + delta);
  p1CurrentScore.value = p1h6.value;

  } else if ((currentHole.value == 7)) {
  p1h7.value = (p1h7.value + delta);
  p1CurrentScore.value = p1h7.value;

  } else if ((currentHole.value == 8)) {
  p1h8.value = (p1h8.value + delta);
  p1CurrentScore.value = p1h8.value;

  } else if ((currentHole.value == 9)) {
  p1h9.value = (p1h9.value + delta);
  p1CurrentScore.value = p1h9.value;

  } };
  let updateP2 = (delta) => { if ((currentHole.value == 1)) {
  p2h1.value = (p2h1.value + delta);
  p2CurrentScore.value = p2h1.value;

  } else if ((currentHole.value == 2)) {
  p2h2.value = (p2h2.value + delta);
  p2CurrentScore.value = p2h2.value;

  } else if ((currentHole.value == 3)) {
  p2h3.value = (p2h3.value + delta);
  p2CurrentScore.value = p2h3.value;

  } else if ((currentHole.value == 4)) {
  p2h4.value = (p2h4.value + delta);
  p2CurrentScore.value = p2h4.value;

  } else if ((currentHole.value == 5)) {
  p2h5.value = (p2h5.value + delta);
  p2CurrentScore.value = p2h5.value;

  } else if ((currentHole.value == 6)) {
  p2h6.value = (p2h6.value + delta);
  p2CurrentScore.value = p2h6.value;

  } else if ((currentHole.value == 7)) {
  p2h7.value = (p2h7.value + delta);
  p2CurrentScore.value = p2h7.value;

  } else if ((currentHole.value == 8)) {
  p2h8.value = (p2h8.value + delta);
  p2CurrentScore.value = p2h8.value;

  } else if ((currentHole.value == 9)) {
  p2h9.value = (p2h9.value + delta);
  p2CurrentScore.value = p2h9.value;

  } };
  let updateP3 = (delta) => { if ((currentHole.value == 1)) {
  p3h1.value = (p3h1.value + delta);
  p3CurrentScore.value = p3h1.value;

  } else if ((currentHole.value == 2)) {
  p3h2.value = (p3h2.value + delta);
  p3CurrentScore.value = p3h2.value;

  } else if ((currentHole.value == 3)) {
  p3h3.value = (p3h3.value + delta);
  p3CurrentScore.value = p3h3.value;

  } else if ((currentHole.value == 4)) {
  p3h4.value = (p3h4.value + delta);
  p3CurrentScore.value = p3h4.value;

  } else if ((currentHole.value == 5)) {
  p3h5.value = (p3h5.value + delta);
  p3CurrentScore.value = p3h5.value;

  } else if ((currentHole.value == 6)) {
  p3h6.value = (p3h6.value + delta);
  p3CurrentScore.value = p3h6.value;

  } else if ((currentHole.value == 7)) {
  p3h7.value = (p3h7.value + delta);
  p3CurrentScore.value = p3h7.value;

  } else if ((currentHole.value == 8)) {
  p3h8.value = (p3h8.value + delta);
  p3CurrentScore.value = p3h8.value;

  } else if ((currentHole.value == 9)) {
  p3h9.value = (p3h9.value + delta);
  p3CurrentScore.value = p3h9.value;

  } };
  let updateP4 = (delta) => { if ((currentHole.value == 1)) {
  p4h1.value = (p4h1.value + delta);
  p4CurrentScore.value = p4h1.value;

  } else if ((currentHole.value == 2)) {
  p4h2.value = (p4h2.value + delta);
  p4CurrentScore.value = p4h2.value;

  } else if ((currentHole.value == 3)) {
  p4h3.value = (p4h3.value + delta);
  p4CurrentScore.value = p4h3.value;

  } else if ((currentHole.value == 4)) {
  p4h4.value = (p4h4.value + delta);
  p4CurrentScore.value = p4h4.value;

  } else if ((currentHole.value == 5)) {
  p4h5.value = (p4h5.value + delta);
  p4CurrentScore.value = p4h5.value;

  } else if ((currentHole.value == 6)) {
  p4h6.value = (p4h6.value + delta);
  p4CurrentScore.value = p4h6.value;

  } else if ((currentHole.value == 7)) {
  p4h7.value = (p4h7.value + delta);
  p4CurrentScore.value = p4h7.value;

  } else if ((currentHole.value == 8)) {
  p4h8.value = (p4h8.value + delta);
  p4CurrentScore.value = p4h8.value;

  } else if ((currentHole.value == 9)) {
  p4h9.value = (p4h9.value + delta);
  p4CurrentScore.value = p4h9.value;

  } };
  let updateP1WithTotal = (delta) => { updateP1(delta);
recalculateTotals() };
  let updateP2WithTotal = (delta) => { updateP2(delta);
recalculateTotals() };
  let updateP3WithTotal = (delta) => { updateP3(delta);
recalculateTotals() };
  let updateP4WithTotal = (delta) => { updateP4(delta);
recalculateTotals() };
  let nextHole = () => { if ((currentHole.value < 9)) {
  currentHole.value = (currentHole.value + 1);
  updateCurrentScores();

  } };
  let prevHole = () => { if ((currentHole.value > 1)) {
  currentHole.value = (currentHole.value - 1);
  updateCurrentScores();

  } };
  return h('div', { class: "golf-app" }, h('link', { rel: "stylesheet", href: "styles.css" }), h('div', { class: "header" }, h('h1', null, "Golf Scorecard"), h('p', { class: "subtitle" }, "4 Players - 9 Holes")), h('div', { class: "hole-nav" }, h('button', { onclick: prevHole }, "Previous"), h('h2', null, "Hole", (() => { const __reactive = signal(""); effect(() => { __reactive.value = currentHole.value; }); return __reactive; })(), "(Par 4)"), h('button', { onclick: nextHole }, "Next")), h('div', { class: "scorecard" }, h('div', { class: "player-row" }, h('div', { class: "player-info" }, h('div', { class: "player-name" }, "Player 1")), h('div', { class: "score-controls" }, h('button', { onclick: () => { updateP1WithTotal((-1)) } }, "-"), h('span', { class: "score" }, (() => { const __reactive = signal(""); effect(() => { __reactive.value = p1CurrentScore.value; }); return __reactive; })()), h('button', { onclick: () => { updateP1WithTotal(1) } }, "+")), h('div', { class: "total" }, "Total:", (() => { const __reactive = signal(""); effect(() => { __reactive.value = p1Total.value; }); return __reactive; })())), h('div', { class: "player-row" }, h('div', { class: "player-info" }, h('div', { class: "player-name" }, "Player 2")), h('div', { class: "score-controls" }, h('button', { onclick: () => { updateP2WithTotal((-1)) } }, "-"), h('span', { class: "score" }, (() => { const __reactive = signal(""); effect(() => { __reactive.value = p2CurrentScore.value; }); return __reactive; })()), h('button', { onclick: () => { updateP2WithTotal(1) } }, "+")), h('div', { class: "total" }, "Total:", (() => { const __reactive = signal(""); effect(() => { __reactive.value = p2Total.value; }); return __reactive; })())), h('div', { class: "player-row" }, h('div', { class: "player-info" }, h('div', { class: "player-name" }, "Player 3")), h('div', { class: "score-controls" }, h('button', { onclick: () => { updateP3WithTotal((-1)) } }, "-"), h('span', { class: "score" }, (() => { const __reactive = signal(""); effect(() => { __reactive.value = p3CurrentScore.value; }); return __reactive; })()), h('button', { onclick: () => { updateP3WithTotal(1) } }, "+")), h('div', { class: "total" }, "Total:", (() => { const __reactive = signal(""); effect(() => { __reactive.value = p3Total.value; }); return __reactive; })())), h('div', { class: "player-row" }, h('div', { class: "player-info" }, h('div', { class: "player-name" }, "Player 4")), h('div', { class: "score-controls" }, h('button', { onclick: () => { updateP4WithTotal((-1)) } }, "-"), h('span', { class: "score" }, (() => { const __reactive = signal(""); effect(() => { __reactive.value = p4CurrentScore.value; }); return __reactive; })()), h('button', { onclick: () => { updateP4WithTotal(1) } }, "+")), h('div', { class: "total" }, "Total:", (() => { const __reactive = signal(""); effect(() => { __reactive.value = p4Total.value; }); return __reactive; })()))), h('div', { class: "hole-selector" }, h('h3', null, "Jump to Hole:"), h('div', { class: "holes" }, h('button', { onclick: () => { currentHole.value = 1;
updateCurrentScores() }, class: (() => { const __reactive = signal(""); effect(() => { __reactive.value = ((currentHole.value == 1) ? "active" : ""); }); return __reactive; })() }, "1"), h('button', { onclick: () => { currentHole.value = 2;
updateCurrentScores() }, class: (() => { const __reactive = signal(""); effect(() => { __reactive.value = ((currentHole.value == 2) ? "active" : ""); }); return __reactive; })() }, "2"), h('button', { onclick: () => { currentHole.value = 3;
updateCurrentScores() }, class: (() => { const __reactive = signal(""); effect(() => { __reactive.value = ((currentHole.value == 3) ? "active" : ""); }); return __reactive; })() }, "3"), h('button', { onclick: () => { currentHole.value = 4;
updateCurrentScores() }, class: (() => { const __reactive = signal(""); effect(() => { __reactive.value = ((currentHole.value == 4) ? "active" : ""); }); return __reactive; })() }, "4"), h('button', { onclick: () => { currentHole.value = 5;
updateCurrentScores() }, class: (() => { const __reactive = signal(""); effect(() => { __reactive.value = ((currentHole.value == 5) ? "active" : ""); }); return __reactive; })() }, "5"), h('button', { onclick: () => { currentHole.value = 6;
updateCurrentScores() }, class: (() => { const __reactive = signal(""); effect(() => { __reactive.value = ((currentHole.value == 6) ? "active" : ""); }); return __reactive; })() }, "6"), h('button', { onclick: () => { currentHole.value = 7;
updateCurrentScores() }, class: (() => { const __reactive = signal(""); effect(() => { __reactive.value = ((currentHole.value == 7) ? "active" : ""); }); return __reactive; })() }, "7"), h('button', { onclick: () => { currentHole.value = 8;
updateCurrentScores() }, class: (() => { const __reactive = signal(""); effect(() => { __reactive.value = ((currentHole.value == 8) ? "active" : ""); }); return __reactive; })() }, "8"), h('button', { onclick: () => { currentHole.value = 9;
updateCurrentScores() }, class: (() => { const __reactive = signal(""); effect(() => { __reactive.value = ((currentHole.value == 9) ? "active" : ""); }); return __reactive; })() }, "9"))));

}

// Initialize application
window.addEventListener('DOMContentLoaded', () => {
  console.log('Jounce client initialized');
  mountComponent(App);
});

//# sourceMappingURL=client.js.map
